// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the txids for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gv+j1/4Lyc6NRfPpw6f/PwAA//+VwoyH2YcBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
