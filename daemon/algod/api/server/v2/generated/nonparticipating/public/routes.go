// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction Ids for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
