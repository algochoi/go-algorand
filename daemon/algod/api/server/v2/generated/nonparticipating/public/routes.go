// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
