// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
