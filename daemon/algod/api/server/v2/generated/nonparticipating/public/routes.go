// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/XPcNpLov4Kauyp/3HAkf+U2qkrdky0nq4vtuCxt9m4jvxhD9sxgxQG4ACjNxM//",
	"+ys0ABIkwRmOJMtxop9sDUmg0Wg0+rs/jlKxLAQHrtXo4OOooJIuQYPEv2iaipLrhGXmrwxUKlmhmeCj",
	"A/+MKC0Zn4/GI2Z+LahejMYjTpdQv2O+H48k/KtkErLRgZYljEcqXcCSmoH1ujBvVyOtkrlI3BCHdojj",
	"o9GnDQ9olklQqgvlTzxfE8bTvMyAaEm5oql5pMgl0wuiF0wR9zFhnAgORMyIXjReJjMGeaYmfpH/KkGu",
	"g1W6yfuX9KkGMZEihy6cL8Ryyjh4qKACqtoQogXJYIYvLagmZgYDq39RC6KAynRBZkJuAdUCEcILvFyO",
	"Dn4ZKeAZSNytFNgF/ncmAX6DRFM5Bz16P44tbqZBJpotI0s7dtiXoMpcK4Lv4hrn7AI4MV9NyOtSaTIF",
	"Qjl59/0L8uTJk2/NQpZUa8gckfWuqp49XJP9fHQwyqgG/7hLazSfC0l5llTvv/v+Bc5/4hY49C2qFMQP",
	"y6F5Qo6P+hbgP4yQEOMa5rgPDeo3X0QORf3zFGZCwsA9sS/f6KaE83/RXUmpTheFYFxH9oXgU2IfR3lY",
	"8PkmHlYB0Hi/MJiSZtBf9pNv3398NH60/+nffjlM/uH+fPbk08Dlv6jG3YKB6ItpKSXwdJ3MJVA8LQvK",
	"u/h45+hBLUSZZ2RBL3Dz6RJZvfuWmG8t67ygeWnohKVSHOZzoQh1ZJTBjJa5Jn5iUvLcsCkzmqN2whQp",
	"pLhgGWRjw30vFyxdkJQqOwS+Ry5ZnhsaLBVkfbQWX92Gw/QpRImB60r4wAX9fpFRr2sLJmCF3CBJc6Eg",
	"0WLL9eRvHMozEl4o9V2ldrusyOkCCE5uHtjLFnHHDU3n+Zpo3NeMUEUo8VfTmLAZWYuSXOLm5Owcv3er",
	"MVhbEoM03JzGPWoObx/6OsiIIG8qRA6UI/L8ueuijM/YvJSgyOUC9MLdeRJUIbgCIqb/hFSbbf/vk5/e",
	"ECHJa1CKzuEtTc8J8FRk/XvsJo3d4P9Uwmz4Us0Lmp7Hr+ucLVkE5Nd0xZblkvByOQVp9svfD1oQCbqU",
	"vA8gO+IWOlvSVXfSU1nyFDe3nrYhqBlSYqrI6XpCjmdkSVff7Y8dOIrQPCcF8IzxOdEr3iukmbm3g5dI",
	"UfJsgAyjzYYFt6YqIGUzBhmpRtkAiZtmGzyM7wZPLVkF4PhBesGpZtkCDodVhGbM0TVPSEHnEJDMhPzN",
	"cS58qsU58IrBkekaHxUSLpgoVfVRD4w49WbxmgsNSSFhxiI0duLQYbiHfcex16UTcFLBNWUcMsN5EWih",
	"wXKiXpiCCTcrM90rekoVfPO07wKvnw7c/Zlo7/rGHR+02/hSYo9k5F40T92BjYtNje8HKH/h3IrNE/tz",
	"ZyPZ/NRcJTOW4zXzT7N/Hg2lQibQQIS/eBSbc6pLCQdn/KH5iyTkRFOeUZmZX5b2p9dlrtkJm5ufcvvT",
	"KzFn6Qmb9yCzgjWqTeFnS/uPGS/OjvUqqjS8EuK8LMIFpQ2tdLomx0d9m2zH3JUwDytVNtQqTlde09j1",
	"C72qNrIHyF7cFdS8eA5rCQZams7wn9UM6YnO5G/mn6LIzde6mMVQa+jY3bdoG3A2g8OiyFlKDRLfucfm",
	"qWECYLUEWr+xhxfqwccAxEKKAqRmdlBaFEkuUponSlONI/27hNnoYPRve7VxZc9+rvaCyV+Zr07wIyOP",
	"WhknoUWxwxhvjVyjNjALw6DxEbIJy/ZQImLcbqIhJWZYcA4XlOtJrY80+EF1gH9xM9X4tqKMxXdLv+pF",
	"OLEvTkFZ8da+eE+RAPUE0UoQrShtznMxrX64f1gUNQbx+WFRWHygaAgMpS5YMaXVA1w+rU9SOM/x0YT8",
	"EI6Ncrbg+dpcDlbUMHfDzN1a7harDEduDfWI9xTB7RRyYrbGo8HI8DdBcagzLERupJ6ttGJe/qt7NyQz",
	"8/ugj78OEgtx209cqEU5zFkFBn8JNJf7LcrpEo6z5UzIYfvbq5GNGSVOMFeilY37acfdgMcKhZeSFhZA",
	"98TepYyjBmZfsrBek5sOZHRRmIMzHNAaQnXls7b1PEQhQVJowfA8F+n5X6la3MCZn/qxuscPpyELoBlI",
	"sqBqMRnFpIzweNWjDTli5kXU3sk0mGpSLfGmlrdlaRnVNFiagzculljU43fI9EBGdJef8D80J+axOduG",
	"9dthJ+QUGZiyx9l5EDKjylsFwc5kXkATgyBLq70To3XvBOWLevL4Pg3ao5fWYOB2yC0Cd0isbvwYPBer",
	"GAzPxapzBMQK1E3QhxkHxUgNSzUAviMHmcD9d+ijUtJ1F8k49hAkmwUa0VXhaeDhjW9mqS2vh1Mhr8Z9",
	"WmyFk9qeTKgZNWC+4xaS8NWySBwpRmxS9oXWQLULbzPTaA8fw1gDCyeafgYsKDPqTWChOdBNY0EsC5bD",
	"DZD+Isr0p1TBk8fk5K+Hzx49/vXxs28MSRZSzCVdkulagyL3nW5GlF7n8KC7MtSOylzHR//mqbdCNseN",
	"jaNEKVNY0qI7lLVuWhHIvkbMe12sNdGMq64AHHI4T8Fwcot2Yg33BrQjpoyEtZzeyGb0ISyrZ8mIgySD",
	"rcS06/LqadbhEuValjehyoKUQkbsa3jEtEhFnlyAVExEXCVv3RvEveHF26L9u4WWXFJFzNxo+i05ChQR",
	"ytIrPpzv26FPV7zGzUbOb9cbWZ2bd8i+NJHvLYmKFCATveIkg2k5b2hCMymWhJIMP8Q7+gfQJ2ueolXt",
	"Joi0X01bMo4mfrXmaaCzmY3KIZs3NuH6ulkbK94+Z6e6pyLgGHS8wseo1h9BrumNyy/tCWKwv/AbaYEl",
	"mXkRteBXbL7QgYD5Vgoxu3kYY7PEAMUHVjzPzTddIf2NyMAstlQ3cBnXg9W0bvY0pHA6FaUmlHCRAVpU",
	"ShW/pnvc8ugPRDemDm9+vbAS9xQMIaW0NKstC4JOug7nqD9MaGqpN0HUqB4vRuV+sm/Z6azLN5dAM6PV",
	"Aydi6lwFzomBi6ToYdT+onNCQuQsNeAqpEhBKcgSZ6LYCpp/zzIRvQFPCDgCXM1ClCAzKq8N7PnFVjjP",
	"YZ2gP1yR+z/+rB58AXi10DTfglh8J4beSuFz/qAu1MOm30Rw7clDsqMSiOe5Rrs0DCIHDX0o3AknvfvX",
	"hqizi9dHywVI9Mx8Vor3k1yPgCpQPzO9XxfasuiJ8nKKzilbot2OUy4UpIJnKjpYTpVOtrFl81JDGzMr",
	"CDhhjBPjwD1CySuqtPUmMp6hEcReJziPFVDMFP0A9wqkZuSfvSzaHTs19yBXpaoEU1UWhZAastgaOKw2",
	"zPUGVtVcYhaMXUm/WpBSwbaR+7AUjO+QZVdiEUR1ZXR37vbu4tA0be75dRSVDSBqRGwC5MS/FWA3jHTp",
	"AYSpGtGWcJhqUU4VXjMeKS2KwnALnZS8+q4PTSf27UP9t/rdLnFRXd/bmQAzu/YwOcgvLWZtjNOCGhUa",
	"RyZLem5kD1SIrduzC7M5jIliPIVkE+WbY3li3gqPwJZD2mOLcFGUwWytw9Gi3yjR9RLBll3oW3CPYeQt",
	"lZqlrEBJ8UdY37jg3J4gaq4nGWjKjLIePLBCdBF+T6wfuz3m1QTpQTpsF/yOEhtZTs4UXhhN4M9hjRrL",
	"WxsgdRqEVd2AJhAZ1ZxuygkC6sMujAATvgIrmup8ba45vYA1uQQJRJXTJdPaRrw1FQUtiiQcIGof3DCj",
	"M4bb4CK/A0Os8yc4VLC87laMR1ai2gzfaUusaqDDSVKFEPkA3buDjCgEg/ympBBm15kLsPRReJ6SGkA6",
	"IQY9IRXzvKcaaMYVkP8VJUkpR4G11FDdCEIim8Xr18xgLrBqTuchrTEEOSzByuH45OHD9sIfPnR7zhSZ",
	"waWPSjYvttHx8CFqwW+F0o3DdQOWFnPcjiO8HQ2n5qJwMlybp2z30LmRh+zk29bglbXVnCmlHOGa5V+b",
	"AbRO5mrI2kMaGeadxHEH2USDoWPrxn0/Ycsyv6kNn1GWlxL6nQtnZ7/Mlmdn78n39k3vFxx7Ig/RcVlH",
	"lc/cbVRKjEwgOTPqgRQ0S6nSUdMoLpLPkyq2TUXBWSoDzt/dOaR83cqDGgoDmUJKSxvU6bi2g6COrlOT",
	"iETU2t02CqMLGWhdLHNtL+0Qq3MpyoKoatstFWiq4fNY6uqhY1B2Jw5CK+qHfdEVRsrO1zdwW9uBiIRC",
	"gkLeGmqnyj4VszB9wTFftVYall0Dnv301x7x9p0XDju6huA545AsBYd1NGOPcXiND2NfW/7e8zHetH3f",
	"toXnBvwtsJrzDKHG6+IXdztgaG+rsKIb2Pz2uC3bbZi4gbYJyAtCSZoztFwIrrQsU33GKepGwWGLuF+9",
	"xtevLb/wr8TV84j27IY64xRd75XGFOWLM4jw5e8BvNKsyvkclG5JiTOAM+7eYpyUnGmca2n2K7EbVoBE",
	"H+jEvrmkazKjOSr3v4EUZFrqJnPF+HKlje5tDclmGiJmZ5xqkoPhqq8ZP13hcN4R42mGg74U8rzCwiR6",
	"HubAQTGVxN3EP9inGMHjlr9w0TyY7GcfW9OjGb8OQl9raCSw/d/7/3Xwy2HyD5r8tp98+x977z8+/fTg",
	"YefHx5++++7/NX968um7B//177Gd8rDHop8d5MdHTqc4PkLBsbY9dmC/NbvTkvEkSmShh61FW+S+EX89",
	"AT2ojbtu18+4XnFDSBc0ZxnVVyOHNovrnEV7OlpU09iIlhnBr/V9LKJpLpKCpucoCI3mTC/K6SQVyz2v",
	"S+3NRaVX7WUUloLjs2yPFmxPFZDuXTzaIthdg1+RCLtqMdkrCwTdGI14xgKa1V0SAp68WcktUZTKmfYx",
	"INf7ysVsXGWl2Gz0A4IpCwvqAz3cn4+ffTMa16kG1fPReOSevo+cCZatYgklGaxi8ro7anjE7ilS0LUC",
	"HedDCHs0LMB6J8Nhl2AUPbVgxe3zHKXZNM4rfZij0/tX/Jjb+ENzEtFIv3a2PzG7fbi1BMig0ItYlmpD",
	"5sC36t0EaDlOCykugI8Jm8CkrXdnc1A+QCEHOsNsSTQ0iyFh29U5sITmqSLAeriQQcptjH5QTHZ8/9N4",
	"5MQIdeOSvRs4Bld7zsoi7//Wgtz74eUp2XOsV92zuU126CAbJWLPcgHXDZe64WY2N98md53xM34EM8aZ",
	"eX5wxjOq6d6UKpaqvVKBfE5zylOYzAU58DHcR1TTM96R2XrLZwTR86QopzlLyXkoW9fkaVOiowqo4fhG",
	"BW17F7uSsJsqyl/sBMkl0wtR6sTlfCYSLqnMIqCrKucPR7YZ25tmHRM3tmXFLqfUjR/nebQoVDv3p7v8",
	"osjN8gMyVC6zxWwZUVpIL9UYUcdCg/v7RriLQdJLnzBcKlDkw5IWvzCu35PkrNzffwKkkQzzwQkPhibX",
	"BTQsn1fKTWpbPXHhVkOClZY0Kei8x/yggRa4+yh5L1Fdz3OCnzWScHyQIQ5VL8Djo38DLBw7JxTg4k7s",
	"V754R3wJ+Ai3EN8x4kbturrqfgVpOVferlZqT2eXSr1IzNmOrkoZEvc7U+X0z42Q5f2Jis0xZsuVP5gC",
	"SReQnkOGmdiwLPR63Pjcu6ydyOpZB1O2YoENqse0WjQST4GURUadUN8yTRkMK9DaB429g3NYn4o6K3eX",
	"hMZmfp3qO6hIqYF0aYg1PLZujPbmu7gItJoVhU9Tw3wFTxYHFV34b/oPshV5b+AQx4iikf/VhwgqI4iw",
	"xN+Dgiss1Ix3LdKPLc/oK1N780UKHHjeT9wrtRrmQhjC1WBam32+BCx/Ii4VmVIjtwtXucPmkAVcrFR0",
	"Dj0ScminH5ip1bDt4yDb7r3oTSdm7Qutc99EQbYvJ2bNUUoB88SQCiozrcAVP5N1BVlTLMGCXA5h0xzF",
	"pCrCxzIdKhv+ElthqA+0OAGD5LXA4cFoYiSUbBZU+aIiWHvFn+VBMsBnzInclAl/HMRcBAVWKhO657nt",
	"c9rRLl0+vE+C95nvoWo5IIvdSPgY5hnbDsFRAMogh7lduH3ZE0qdn1lvkIHjp9ksZxxIEgvfoEqJlNmq",
	"MPU14+YAIx8/JMQak8ngEWJkHICNLk4cmLwR4dnk812A5C6/lPqx0Tka/A3xUHgb0GhEHlEYFs54T+is",
	"5wDUxfxU91cr8gyHIYyPiWFzFzQ3bM5pfPUgnYRsFFtb6dfOyf6gT5zdYMu3F8tOa7JX0VVWE8pMHui4",
	"QLcB4qlYJTYXJirxTldTQ+/RGE/MzIkdTJv6fk+RqVhh4AZeLTamcAss/XB4MAINf8UU0it+13ebW2A2",
	"TbtZmopRoUKScea8ilz6xIkhU/dIMH3kcj/IZr8SAC1jR1330Sm/W5XUpnjSvczrW21cV2nx4fOx4993",
	"hKK71IO/rhWmyj93JoR3kAqZ9dspDKEyXRXS7JoXXBlQwzcGZ6hvKOp52NQ2vArR3bme+IIGPPU8GxBx",
	"ZJM/OpC8XBXCSLc2OcRWCnBIsXKiBJvzpqzNSjE+z51g0Iem2IJ9dJPHuF1yXfnHDzhMdo5tbo+SvwmW",
	"oojDsYum8s7hZwMUPae8hgPl8GtC4qoFbITlUz99vG2L9tGD0gzUadaoCHSt2O1gyKfrF+16XxXkgNpz",
	"0tA2kvOYt/zs7BcFKJqd+M8CKx9WwqB8/SCI/pIwZ0pD7bcyEqzH9G3b8SkW4BJi1r86XciZWd87ISp5",
	"zlZ4wQ8by7z1FVwIDcmMSaUTdPpFl2Be+l6h9el782pcqWjGl9lalCyLX6I47Tmsk4zlZZxe3bw/Hplp",
	"31SygyqnKJgwToCmCzLF2qnRqNMNU9vA5I0LfmUX/Ire2HqHnQbzqplYGnJpzvGVnIvWTbeJHUQIMEYc",
	"3V3rRemGCzTItexyx0DBsIcTr9PJJjdF5zBlfuytkVo+47NPmLMjbVgLBhn1hvlGQntsRJpl6nXZ9GhW",
	"JBc6aRg/IuiqDDxK03Ob2dPcYD6vbCrxACyrVw8a2r27ZUA+fDy+fTgnBCc5XEC+PZyaIsa9AQdjLOwI",
	"GMRDMDHBR4tsl+q7O1AjrFppG8YotXSkm02O21o1coXMat0aCdbgzqUgD/beGQnN01tN313XXVEkGeQQ",
	"Tfj5e5DRQ4sC0/b9y7HkFzMY4xms4uDYR+NYcfOu8b5kXNtCmDdVY681zvBlh5XohqCgsDXTdq/j169j",
	"BrsUorl/UT1EWTkHNjJiHLzS7IK2EG3q67nGaVGwbNXye9pRe63jN4IxvKDcYFswENBGLJVMgmpWIKyN",
	"ebYOdqMA0GQQZk6bdQJDmSaciinfxaGLqCrVdBuuToHmP8L6Z/MuLmf0aTy6nps0hms34hZcv622N4pn",
	"DOizbrNG1MOOKKdFIcUFzRPnTO4jTSkuHGni6973fMvSWpzrnb48fPXWgf9pPEpzoDKptJ3eVeF7xVez",
	"KlvssOeA+CrxC6or+5zVhoPNryq0hQ7oywW4ityBQt0pHVoHFwRH0TmkZ/G44q3uZRcHYZe4IR4Ciioc",
	"onbV2WiIZgQEvaAs9z4yD21PDDAubtjdGOUK4QDXjqQI76IbZTed0x0/HTV1beFJ4VwbaoYvbVl8RQRv",
	"h8sZLRhdb0iqS4qFP60HpMuceLlEr0GicpbG/al8isk63MbJmJcJvtyjT5sRS9YTdsVLFoxlXlMDjNot",
	"IIM5osj0RWT7cDcVrp9Rydm/SiAsA67NI4mnsnVQ0X7qPOvd6zQuVbqBrTe+Hv46MkZY9LZ94zmZa5OA",
	"EUbldMA9qqx+fqGV98n8EIQf7BDcF87YuRI3BOY5+nDUbFMeFs3omsES+tbeR97+5qrv9swR7WXEVDKT",
	"4jeIm6rQwhfJM/VlfhlGtP4GfEByWu3JqVsy1bP3bnefdBN6nJoBiT1UjzsfhOBgvVHvjabcbrVtLdKI",
	"a48TTJiLsmfHrwnGwdzJ38np5ZTGirEaIcPAFLhfGn5zLYj/2OPe+WiYq7w8IUHcWPUusxUYCpB1Cni3",
	"mtMVBQY77WBRoZYMkGpDmWBsY31yJSLDlPySctuhBr0ReJTc10bB9wahSyGxfoqKu/gzSNkyalw6O/sl",
	"S7vu3IzNme3PUioIGoC4gWxjK0tFromKDaerUXM8I/vjoMWQ242MXTDFpjngG4/sG1OqwBpVfOSG/8Qs",
	"D7heKHz98YDXFyXPJGR6oSxilSCVUIfqTRWoMgV9CcDJPr736FtyH0N0FLuABwaL7n4eHTz6Fh2s9o/9",
	"2AXgGjFt4ibZLEyXjdMxxijZMQzjdqNOotYA2z2vn3FtOE320yFnCd90vG77WVpSTucQjwpdboHJfou7",
	"ib6AFl54Zls/KS3FmrCexGXQ1PCnnpw1w/4sGCQVyyXTSxfIocTS0FPd3cNO6oezfaRcYWYPl3+I8VCF",
	"DwdpKZG36/ex91ts1Ri19oYuoYnWMaG2aE7O6khFXy6eHPuaXFipuipQbXFj5jJLRzEHAxdnpJCMa1Qs",
	"Sj1L/kLSBZU0Nexv0gduMv3maaQ6d7NKLN8N8FvHuwQF8iKOetlD9l6GcN+S+1zwZGk4SvagzhENTmVv",
	"4FY8RKcvTmjz0EOFMjNK0ktuZYPcaMCpr0V4fMOA1yTFaj070ePOK7t1yixlnDxoaXbob+9eOSljKWSs",
	"0GZ93J3EIUFLBhcYpx/fJDPmNfdC5oN24TrQf1nnqRc5A7HMn+VeRWAXj0+gG6DPJ4xMvIq3p+npachc",
	"UbcPajjDPCC2+eQ2v8d12tI0Pt4FKs+hh0HXY0RoJMC2MLabBnx9E0Pg8mnsUB+OmkuLUeZzEVmy72VQ",
	"+XhcxmTEbtV3gZgHhkFN3VBj0qwbf/sRNd4t0o3sME88rPhHG9gvzGwQyX4FPZsY9LSIbmdWPQ+Cyyh5",
	"LlZDN7XFu/3G/g5QE0VJyfLs57rKSKtliKQ8XUSDRabmw1/r5obV4uxhjlZaXVDObTRC1zaBWsqvXpuJ",
	"6Fv/FEPnWTI+8N12FxO73NbiasCbYHqg/IQGvUznZoIQq82yC1VaXz4XGcF56rKe9b3e7X4T9Cj4VwlK",
	"x+5FfGBTC9CiPjNUbFsFAM/QjjEhP9jm5AsgjaqDaD+w9Z4g8wXbraunLHJBszEx45y+PHxF7Kz2G9ui",
	"y5bon9trt7GK/vjcXQJtN8XW3kRGn1m10lgEVGm6LGLFTswbp/4FrKgSepdQsQ6xMyFH1qahvMZsJzH0",
	"MGNyCRmppnNSNdKE+Y/WNF2gsaDBUvtJfnhvCU+VKujnWvVlq8r44rkzcLv2Era7xJgIIzlcMmV7UsMF",
	"NOurVMWGnBjg6600lydLzi2lRKXiTcWwroJ2D5yNgvQOqChkLcTvKL24MPUdW22c4FfRupjtvh2dRq62",
	"xkbVb+u1b8VLueAsxaqUsavZ9bce4p0dUMAznhng4m3UKHK4ot1CqmQNh8Xe/iGeETrEdd1DwVOzqZY6",
	"7J8aGykvqCZz0MpxNsjGvumNs1AzrsCVZcZW5wGfFLLh8UYOGQ2iqOXkHckIk7N7TA7fm2dvnEEKsxbP",
	"GUfV0+dI2ARJa0PG9rva6KtMk7nADAp3KMI1/WK+mWCxlgxW7ye+XS+OYR3GZtk2OqI71KGPlXCxCebd",
	"F+ZdW5qv/rmRB2cnPSwKN2l/S6SoPKBXvBfBEZ93FegVILcaPxxtA7ltDHLC+9QQGlxgiAQUxKXG9LQH",
	"aiXBGKHVUhS+QWx8dLQiVzRM9BXjUDeTjlwQafRKwI3B89rznUol1VYEHMTTToHmGBcRY2hKO6fYdYdq",
	"bbCLJy3SkZ+jfxvrzkY9jKN6oRbcKF9XPawNdQfCxAtsnu8Q2e1ThFKVE6Jcck2zc1GMcRjG7Ut7Ni+A",
	"7jHoykT2cy2pPTm73ER9pUqmZTYHndAsi9kTnuNTgk994VNYQVpW9cCLgqRY469Z9LBLbW6iVHBVLjfM",
	"5V+45nSpiMnRb3AC5RN368EnBNmvYb1HL9++e/ni8PTlkb0vFFGlrVViZG4JS8MQJ+SYKw1GdC4VkA8h",
	"Gj/gdx9aC46DGXQsixBt2DXNEyLGh0/X+G+sZnc/Abkopp1TAXzIUlZl+e0i3jdH6gjn5uglis2T4ZjA",
	"q+/66Kinvtp5rL+/0QOZi3kTkFuuo7aJGYd7FGPDL839FpYZ6xSitzdgVQUMo1aF7zOL2m1Vv6bJPH1y",
	"bGfOoNT0ZjtJf0fKMd7RPek3gUmaWjHAut/7knDS3pwxql2ZB03JRk7Zmzpvw99skjxCEXc99IW82Yg3",
	"87jz9TABtqMO4NgbEepjKbsA/egDtUlBmYstqZlFF7MuK63fqrnp0NUb3F6Ey/XqNSz+eNGXl+XTlW0C",
	"SquH3zm42k+FhAsmSh+14cP6vOZqf3U91IP05971d8N7cKova63ttS2fun4xdpnOdPDjzzYIlADXcv07",
	"sDR3Nr3TATFWpLnR/9DJgFGzmB56Vx5VTRTPL5KlyDbldf/4MznyLrBB944n5FhVKJG5rmPRnPZXrueF",
	"f80IyYOnfe0+OiyKzVP3JLJ3J7cv7jp9X0Uscz43GQff+vNr+0aGlo6IShVkXXNY6XiHqE7S7iUQWBWA",
	"JXmD/Ov+Ih9DCcrlYqJSneRAFWzAcFhczr07EMmnq1fm/WE1AeKdO/sr49bVcJF5FkKxuhtRrKXnwMjo",
	"U+zKGTg2u2P5sMQLSLWQjXArCbBLnV8zWdAu+q5Cbo89pwog9/S/oRrueBTylmg+pTtetK7kg84/9AxH",
	"avPbdyLM3n3MzCEpYeyHMD/MaK7izdl6Y3JbBVqCuJpIPer4wo6zAeXN3XLGQagGyzYjMp6wYGPU/5jI",
	"tOH3N4vOTpOyzVpFpz5EUOPE9pKa7BDnUgV7o2SI+zUH7jqJz2Ko2Z68NZtBqtnFlnocf18AD2o9jL3B",
	"GmGZBeU5WJUMhHVPd3fH1ABtKpexEZ6gk8G1welLZT2H9T1FGtQQbW419sL9VUpeIgbw1jKCRyFULJjS",
	"ethcfBtTFWUgFnzwsv0c6uLhvV1FAznninN5kmxKPBumvBAxE/2gucynOxUsw7yWvpId3b5+/RaPI2yj",
	"qKqO375kZmi+JMeRzleu5CZWT6mcyr74Jij/my+VZGfJ2TmEfU/RhY+VHtwbUZu0N3cnG+SkTpJ6tF0X",
	"lvjyM7M61aSblhwpVY1BWmkusNVVX1ZWM7ujika7p2wMK4op2HoL4ZqBdP2h8WbIhYJECx8BuAmOTaiw",
	"gbpXQoLqbQ9hgest2vqurkqLDXdsTQ/q4nPDBRIJS2qgk0Ht2P45NyH7hX3u83B96bABpndHr8nW4q8+",
	"yYipDhJDqp8Rd1tuz++9inmbcQ4y8S75dugjN6gM3cSFFFmZuno1wcGonQlD9aYNrCRqGU67q+wY+XIs",
	"Wv4qqJZwDus9a39JF5TPgypwIfRWtLdrCAqstXb7Ri3/cSNnPrcLmN8InF/Sej4eFULkSY9f+LhbD7d9",
	"Bs5Zem7E7LIOz+/pLEruozuyCvy5XKx9/deiAA7Zgwkhh9wmRPkYoGZrp9bk/J7eNP8KZ81KW6LaGfYn",
	"ZzyeWYK1h+Q1+ZsfZjNXU2CY3zWnsoNsqba66qnFK+llpM9uN+xvcFROu/dpTVQWipiUcsWKYoPOd9e4",
	"HyH9oO3jZu0nLDhYB1tL6yNCaaluhdkUXl7Xrp9hDSj9B1vAC401QQtKz40cOF84Ivp1hZRgKb2U0Fj+",
	"NvuPW2DNl4ItUpjcaZZp6yTbaLrmvgTGPfWispnF8dw1rWF1QcGxNHHXJKfQZ2irxQaEY86lvKD57ZvV",
	"sOzkIeLDddOPLzTUf0MkW1Sqq4UlvqKD5g503Zubmr9FM+DfwexR1NnrhnLOn6r1p3eRYSV+mpNc1I2g",
	"cUhyiWNa7/Cjb8jUJfsVElKmWCsP+tI3X6nUPexF5kJBV3qLfrltnT8LfQ0ydgqCKMibupGDFng/1BDW",
	"R/QLM5Wekxul8hj1dcgigr8Yjwqr7my5Ls4bbmPbGKcVtikk3LD7OIhX29F93K0nNHR51kVqLp1SQXed",
	"g2/rBm4jF3W9tqGxD13kbqr2PyRkId7Ew3yOMRMWIdgBhyCo5MOjD0TCDFtcCvLwIU7w8OHYvfrhcfOx",
	"Oc4PH0bFuFuLlrA4cmO4eaMU45xpnYwdWBVM9tQmfOeYu7uw0X1H8AOIFxHNIdq0Bqf24a23XLEaZe6t",
	"Bn67NPfyNn4WoMwvuZoohvuf+1IsbBpBTzZP6yyULM+2HcpGblbd6hezj351ecNfpNnwr9aW3WWTrk3j",
	"LjFy7QOAiImstTF5MFWQdTUg4cp9FkmvQuJKS8n0GsuZedMn+zUaU/ND5S1xXuCqAI6TO7Q4h6ogXu1b",
	"KZWXbH4QNEdZwOgzGKGohcgn5OWKLoscHJP67t70P+HJX55m+08e/ef0L/vP9lN4+uzb/X367VP66Nsn",
	"j+DxX5493YdHs2++nT7OHj99PH36+Ok3z75Nnzx9NH36zbf/ec/cAQZkC+jIF88Y/Q925E4O3x4npwbY",
	"Gie0YD/C2rbsNGTsm4HSFLkgLCnLRwf+p//judskFct6eP/ryOXmjxZaF+pgb+/y8nISfrI3R2NqokWZ",
	"Lvb8PJ1uoYdvj6ssNhsLhTtqE5QMKeCmOlI4xGfvXp6cksO3x5OaYEYHo/3J/uQRllwugNOCjQ5GT/An",
	"PD0L3Pc9X+v44OOn8WhvATRHn7j5YwlastQ/Upd0Pgc5cV1RzU8Xj/e8GLf30RmSP5lR5zG/qc3HC5Kw",
	"us1CnVMKg5ptvl2j+ZZylbDHVUs2Z+fhGaZJWdusYfEVso6zOtv9uGZUviqbLVN78EskoGnG5qVE41Gd",
	"RV6Farp+jUyR/z756Q0Rkjh18i1Nz8PYLSTIf5Ug1zXBOFYW1lf17bNcwtJSzYtmdH/N0iOqRbTrKs5s",
	"9jmg1MqnU3Mi9DqHvaorvmp45X7y7fuPz/7yaTQAEHQwKsDqOx9onn8glwybd6KXppmBr8aRVlGomoxr",
	"HwF+UG/TGNMTqqdhN9DqnWZS3AcuOHzo2wYHWHQfaJ6bFwWH2B68x/owSAl4iB7v799YG+EqD9QmOVSj",
	"eJK4wkBdDmMfVe2ILyUt7EHzdSEwqxbtCn6h2Dz56Q0utBkefe3ltofrLPo5zbBDIyhtl/Loq13KMUcf",
	"v+H4xN5on8ajZ1/x3hxzw3NoTvDNoPha9xb5Gz/n4pL7N400Uy6XVK5RVgnayLZyzOlcobkYWaQ9283K",
	"/e8/9V5pe2FfvL2PDTdxdq0Lr9MS9Phoyx14T/Vxzm7p4lbbPdcswJYSQUei6y2Ifd7Ugwn5IfwauTdW",
	"ArJ1dkrJXaCSs02xzPBhp5D4gok1bPdUGH8UvZED2/vd5fxZL+fDplmoUfs2BkyDxDfC1Ikjue7t2M0T",
	"vIluDkF3uyv0DfisrVtbmqGd6X1McdvKhe9w14O7PhkogLcSh5rN1j4/3/UJL9U10bgPPiNX/solutc0",
	"N3QSLLdVs8AWhL6T9P40kl4VWji3opfrgXA92Q8zbPY++iLfNyDvuSLnAyS9RtW6+tugCPX9Fjt5MHFN",
	"LoN3rsYzXCzhVhkOS6/fSW+fW3rr9iyIgVFXov9yEtt1Sjs2+g3vVBnxKxXR/sTI6pXJXHHULdLYFXhj",
	"R9JynPiz8cw/pITlkHYnW/2pZasqfP9a0lWj64hLCAm8S9eyu7XtakxXYlYzhSPgbJhSYhiKO8LjukOa",
	"YTFYGsyXW1Fjr/ahZ9NqhHazxh2lsCs//QCh9vl8fXy0TXT6iow4g0tURm6B+N58bl4adRi8ux2HwTDe",
	"9HT/6e1BEO7CG6HJ93iLf2YO+VlZWpysdmVhmzjS3tQWz97ElXiLLSGjqItiBzwKu+KEhbdtoMR91049",
	"rBLyYEJ8iW5VtcJx6fpzYRiULxVG5dx+ZHicQQK55/88wPHvTcj3QhLGtbLVvLTrk0LuMa4PHj1+8tS9",
	"IumlDWVrvzf95unB4XffudfqVgFWv+m8rrQ8WECeC/eBuxu645oHB//zv/+YTCb3trJTsXq+fmOrH/5e",
	"eGpXrQs3vm+3vvJNimnprirlVtTdisP9uVhFub9Y3d0+X+z2Mdj/Q9w60yYZOQW0Mk820oBv8Bayx2SX",
	"e2jsC5wbvlNdJhPyRriKDGVOJREyA+l6h81LKinXANnEUyqZYeo1ZqCnOQOujcKI3ZBkolgGNpF1XkrI",
	"SM6W2C5cwgWmCOD0qMs3INjO6DGo93fL5F/TVZClPa2uaS3ckjHnfUlXvh8bdhwSEn/67juyP661ljw3",
	"AyQVYmLMdUlXo1u09lXENij8vtmYYmuMLI49xHJUSz+29SVtVsH/c3Pur1Zit+TuNvaGOOfO3pzaWxPa",
	"D1zdg42WAyvY2W5t2D5sTaq8ZCPleREqzuLMDEONAr9j38BWk3RU+Wyj9+4Q3yn/12IlbYLakW1g0q3a",
	"+4i+jJBndM4tJg3+gXyggUNIiqX3CAkyA50uXDJyC68R3uN7XvQznk29eG9aZMEt6pZcD2sdYo/YgUUK",
	"gjxR9MqBjFDoT76us3nMZlhqoupn4ltOo7+J+S6MVQNG16aWKR9e73OWzS7uBOWLevKutIVouQmn5h2C",
	"d0Nwh/O99D3VEGNuEX+EAHyvJybkjahT4l07jz+iP/FzXtufe0FvBAfrODdiraXFOx9pJVOgfR6R4muh",
	"WOWkqlh+Zfliz3cH3Chk/NX25tsoaAy5vc1kX+UV/tdoR/jGLWPWNtmaGF2PNoQ5mxdtveVmpeUvqKJ8",
	"EX76O9RbvgTHuh0Wg4fU8xknFvCbZTpYXsgS815VzLSPA8Xrlg/mRlpUsWXRUuNTyAWfq98nK9pEHXG8",
	"RKikqugeL9v+5zu7L7ByERe+SKirZaUYT8F2v8SOOEyRJVPKRUA+3f/L7UGo2dLX/+NhKukX5i7P9p/c",
	"3vQnIC9YCuQUloWQVLJ8Tf7Gq06l1+F2WPy7qi3nTb3RPgToSmrWPEvDAk1XZ4KNeLSPesWyT9uZYVCf",
	"cEc+yHjAB8Oak7QogMqrM8DtfqnT1ozHR2HIb6MmdVUtLAKKQdGOUe//MRpod8IsdDFzl1/JLaC+splj",
	"Ey4eV8zGVeSLkQLE7ICc8YdELeizR49/ffzsG//n42ff9FjOzDyuIFHXdlYPZB7bYYYY0H6/tr6bFckr",
	"5B3c9lbutkPjEctW0QK0dfOT8Fy4wBzkE/cUKei6t251saV5Szhs3cjl9qs0Ks2mi6jy5HWbquXyMX9e",
	"qbi2lKDreXLXtKUn3SFgIobQ6u4tFdY3N3LZICq2yLLqTHDbmmedFmBvMY882bpQvqgUq7+UBpqgAgrc",
	"Sy1NtHw5gRGLJI8DR3XVxB6jTsqiEFJXp1tNBsly0Odwa4hyfYS7k6SWUp0uymLvI/4Hy2N9qlMFbD/W",
	"wEPnfrcd6fas/32TEHdi37jmndiSlq3XXzaZk6/U5mICxIy8ZqkUh1h72103aq00LLt9hOynv/Zkb/m6",
	"o92rSfCccUiWgseKvP2ET1/jw942a30fY1u1vm/bbYMa8LfAas4zhDNeF7+/Ez37Wvah1molmGNcN0yy",
	"9L/jUfOHZs3T7kla87R7zBpdm3p+3vvY+NNF37g31aLUmbgMvkXtzvKiIY73oPD3cKN4pfC0CmgrkoEy",
	"RPv1WaACPMROTPU0Uv0rKO/eWwDsT2qTmjGetYgEJcpUXIBUlbVC+kCZO8PUH8cwNXjfd+KxtpTlNo5W",
	"qpuVSN6IDOy4zeqxsURPLjJwFTe7gkglg8X1fX8r1e+1NLCUlvOFJmVBtIjpevWHCU0tk7V93dS2Rlj2",
	"Ld/w5QIIzSXQbE2mAJyIqVl0s6EgoQqD3Ku2iVbSjPdzquEqpEhBKcgSn9i6DbSqjimql3oDnhBwBLia",
	"hShBZlReG9jzi61wVnXXFbn/48/qwReA14qCmxFrQ2sj6K0ifJy014V62PSbCK49eUh2VALxogHat8Sy",
	"yMFZuCIo3AknvfvXhqizi9dHC5qA2GemeD/J9QioAvUz0/t1oS0LbLgd6Thnn56yJUpinHKhIBU8U/19",
	"IbexZex9EqxFmRUEnDDGiXHgHoXzFVX6nfNkhO2zgh4rZooNjSz7asybkX+uKsx3xk7NfchVqaoy9M6A",
	"AVlsDRxWG+Z6A6tqLnQl+bErC4kWpFSwbeQ+LAXjO2SpsDOlDnxA2AGluzisRkKdgaKLygYQNSI2AXLi",
	"3wqwG/onegBhqkZ01W6uSTlBn2KlRVEYbqGTklff9aHpxL59qP9Wv9slLtfUAe/tTIAKrVcO8kuLWYXp",
	"FguqiIODLOm5M3DNXbWmLszmMCbodU42Ub45lifmrfAIbDmkbWNIePwb56x1OFr0GyW6XiLYsgt9C46Z",
	"X77KbKa21+szxus0zU+B+Dy5imqwd0mZTmZCun7GdKZBRiwhrSrslGmfLGXtz1o4bzLBERzXceO4vrh1",
	"xQHX0tCCQHwrRraMFDAxU30v5KCMh2boD2WalFyzPMj6rBSN35+55U6FulOh7lSoOxXqToW6U6HuVKg7",
	"FepOhbpToa6jQn2pJJHE82sfXccFTzjMqWYXUGWP3BWt+EMFVVcn3at0qAQaFcyVgLtmFokGmuOqWW7b",
	"dArVW00Du6YqUcoUSGpgYpwUOTWyFKx0VYKoWdzOl9t0fVOxXh5V8OQxOfnroQ8IXbjAxea79327TKXX",
	"OTxwecBVcz2fEAzcoNnlA1OvAvtSRa5wE8uBKIPQl/j2EVxAbtQ5G2tGjELaVZFPgeYvHG62aMiN9mlm",
	"tA/jhmLu0LakRdAfGtdKFaEYPNzqfjajuepvf2bHW9IiVi2oYuZWd0b+8Vxk69aZMLu2hxvYPA11WCjj",
	"VK4j8d6dM9AhDS0Mh3KE1VX+P9148HKXaLtkto3CYuKNBBU9uZuoPBq1W21YZygbOT5r0Um092c7VHVU",
	"ATgk4MrQs98T8s5+92XzHhEid8Rq9v27iVNpvlkxDXzXSF2O9XytSYoe8dHTi2d/bAg7K1MgTCvi45+3",
	"Xy/j0SoxI82BJ44BJVORrZMG+xo1bqGMKaoULKfbb6KQf7r6mO7yMU8231Nf5ho5Cha3iSeHRLNKHAPu",
	"4c42aH8Yb66whSM69hxg/HOz6D42GoJAHH+KaeHtrgQ7Mr16mvUd47tjfMFpbEkEjLt8kTYTmXxGxifX",
	"suT9PO/lCtLSABee5PtozkQfBqx0wxGUwbScz7HOZ8epYZYGOB4T/AuxQrvcoVxwNwqyg1e1365bkaQ9",
	"XJe7BLkR94UkcynK4oFtaMLXaP1dFpSvvY8MEsWWZW5xaKso3SyjtSkdsYb23pbXbwZ86619gbHLXbXN",
	"3y1ayCVVrrE5ZKTkmYtU7yR+rfjwGqN26NMVr9n0xiqjdr2R1bl5h1wRfpddSHXlFyxAJnrF7YFqFgK2",
	"CWb25E7u6hv+Oa6Nt7ZxUA+D7SZL1Qzhhm4PGfA1vD6CfPc69aLZlcX2jOoLVA6T3+2bN+pt7wzfdLoH",
	"HZusUwnyglBffDoVXGlZpvqMUzRqBwubdB3y3lTfz99e+FfifpWI28MNdcYp1iauTN1RPjeDiBPrewDP",
	"RlU5n4MyvDIkkhnAGXdvMU5KbjQtMSNLlkqR2LQnc4aMfDKxby7pmsxojl6Z30AKMjU3e7Dr1kSsNMtz",
	"FwFgpiFidsapJjlQpclrZrisGc5bEavQF9CXQp5XWIinS8+Bg2IqiRtffrBPMSPZLd8b+dBgaR/XmYS3",
	"m4rsYWdZL+THRwZuipUVcqZ07TTuwH5rDsMl40mUyE4XQFwMTZu2yH3DeD0BPai98m7Xz7i54bQgyNWp",
	"vho5tB07nbNoT0eLahob0fL/+LW+j5VvnIvEyHF0bn6fM70op5NULPd8Wce9uahKPO5lFJaC47NsjxZs",
	"TxWQ7l082iLOXYNfkQi7unPL/IFSigI6MKel2njsf9De+x0dMhtbqsWeukI3PS85dQP8Y3seUVowy4K0",
	"lEyv0aNBC/brOZj/v//03jyTF97ZUcp8dDBaaF0c7O1hr7SFUHpv9GkcPlOth++rlX/0fotCsgusrvr+",
	"0/8PAAD//zwh126RQAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
