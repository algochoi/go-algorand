// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"D97aUEh2jjmq33/8/wEAAP//nKy5x9ZLAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
