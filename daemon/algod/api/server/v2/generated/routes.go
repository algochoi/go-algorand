// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"JbvAVL7vPvy/AAAA//+zbadj8hgBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
