// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jzQxNwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
