// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"7HL2/uP/CwAA///d3nE9K0sBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
