// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5/gWz9sP/z8AAP//8Dvb7jI0AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
